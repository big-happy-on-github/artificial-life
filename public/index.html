<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Artificial Organisms</title>
    <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>
    <div class="container">
        <h1>Artificial Organisms</h1>
        <p>made solely by lim</p>
        <h3>WATCH THE CHAOS</h3>
        <canvas id="gameCanvas" width="625" height="425" ></canvas>
        <p><small>made with ❤️</small></p>
    </div>

    <script>
// Constants
const CELL_SIZE = 10; // Size of each cell in pixels
const CANVAS_WIDTH = 625;
const CANVAS_HEIGHT = 425;
const ROWS = Math.floor(CANVAS_HEIGHT / CELL_SIZE);
const COLS = Math.floor(CANVAS_WIDTH / CELL_SIZE);

// Canvas and context setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Define organism class
class Organism {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = Math.random() * 2 - 1; // Random initial velocity
        this.vy = Math.random() * 2 - 1;
    }

    update() {
        // Move organism
        this.x += this.vx;
        this.y += this.vy;

        // Boundary conditions (wrap around canvas)
        if (this.x < 0) this.x = CANVAS_WIDTH;
        if (this.x > CANVAS_WIDTH) this.x = 0;
        if (this.y < 0) this.y = CANVAS_HEIGHT;
        if (this.y > CANVAS_HEIGHT) this.y = 0;

        // Collision detection and handling
        for (let other of organisms) {
            if (other !== this) {
                if (this.isCollidingWith(other)) {
                    if ((this.color === 'rgb(255, 0, 0)' && other.color === 'rgb(0, 0, 255)') ||
                        (this.color === 'rgb(0, 0, 255)' && other.color === 'rgb(255, 0, 0)')) {
                        // Handle collision (both organisms die)
                        this.remove();
                        other.remove();
                    }
                }
            }
        }
    }

    render() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, CELL_SIZE, CELL_SIZE);
    }

    isCollidingWith(other) {
        return this.x < other.x + CELL_SIZE &&
               this.x + CELL_SIZE > other.x &&
               this.y < other.y + CELL_SIZE &&
               this.y + CELL_SIZE > other.y;
    }

    remove() {
        // Remove organism from simulation
        let index = organisms.indexOf(this);
        organisms.splice(index, 1);
    }
}

// Array to hold all organisms
let organisms = [];

// Function to create initial organisms
function createOrganisms() {
    for (let i = 0; i < 100; i++) {
        let x = Math.random() * CANVAS_WIDTH;
        let y = Math.random() * CANVAS_HEIGHT;
        let color = Math.random() > 0.5 ? 'rgb(255, 0, 0)' : 'rgb(0, 0, 255)';
        organisms.push(new Organism(x, y, color));
    }
}

// Function to update all organisms
function update() {
    for (let organism of organisms) {
        organism.update();
    }
}

// Function to render all organisms
function render() {
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    for (let organism of organisms) {
        organism.render();
    }
}

// Start the simulation
createOrganisms();

function animate() {
    update();
    render();
    requestAnimationFrame(animate);
}

animate();
    </script>
</body>
</html>
